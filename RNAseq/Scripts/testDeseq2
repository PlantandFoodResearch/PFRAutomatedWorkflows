#!/usr/bin/env Rscript

# This Deseq2 script return some statistics about he diffrential expression workflow of the data. These statistics allow to know if the ocnditions have an effect on the expression of RNA
# To know the different conditions we need a file text with table who inform about sample ID, file Name and Conditions
# Thus args[1] is this file the user need to give at the very beginning of the pipeline

library('DESeq2')

library('base')

args <- commandArgs(TRUE)

# Collect information from the file table

#In this file, the columns are separated by a tabulation

target <- read.delim(file=args[1], header=TRUE, sep="\t")

#Collect ID, file name and conditions in vector:

sampleName <-c( paste(target$id))
sampleFile <- c(paste(target$id,"_sub_HTseq.counts",sep=""))  
sampleConditions <- c(paste(target$group))

#Build a table with these 3 vectors

table1 <- data.frame("Name" = sampleName, "FileName" = sampleFile, "Conditions" = sampleConditions)

# The DESeqDataSetFromHTSeqCount function is used to create a matrix of reads counts from HTSeq files generated by Python script.

ddsHTSeq<-DESeqDataSetFromHTSeqCount(sampleTable=table1, design=~Conditions)

#The function factor to the column of interest in colData, supplying a character vector of levels. It is important to supply levels (otherwise the levels are chosen in alphabetical order) and to put the“control” level as the first element, so that the log2 fold changes and results will be most easily interpretable.

colData(ddsHTSeq)$Conditions<-factor(colData(ddsHTSeq)$Conditions, levels=c('control','hot psyllid'))

# Differential expression analysis

dds<-DESeq(ddsHTSeq)
res<-results(dds)
res<-res[order(res$padj),]
head(res)


# MA-Plot: show the log2 fold changes from the treatment over the mean of normalized counts. Deseq2 incorpore a zero-centered normal prior.It's how much a quantity changes between an original and a subsequent measurement. It is defined as the ratio between the two quantities.
# Here it's show if there are differentially expressed genes
#By default, the last variable in the design formula is chosen, and points will be colored red if the adjusted p-value is less than 0.1. Points which fall out of the window are plotted as open triangles

plotMA(dds,ylim=c(-2,2),main='DESeq2')
dev.copy(png,'deseq2_MAplot.png')
dev.off()

#mcols function give information about which variables and tests were used.

mcols(res,use.names=TRUE)

# For a particular gene, a log2 fold change of −1 for condition_treated_vs_untreated means that the treatment induces a change in observed expression level of 2−1 = 0.5 compared to the untreated condition.

#Text file of result
write.csv(as.data.frame(res),file='sim_condition_treated_results_deseq2.csv')

#Data transformations and visualization
#Transformations: for visualization or clustering it might be useful to work with transformed versions

#Regularized log transformation: transforming the original count data to the log2 scale by fitiing a model with a term for each sample and a prior distribution on the coefficients which is estimated from the data
#The regularized log transformation is preferable to the variance stabilizing transformation if the size factors vary widely.
rld<- rlogTransformation(dds, blind=TRUE)

#Variance stabilizing transformation: 
vsd<-varianceStabilizingTransformation(dds, blind=TRUE)  

#If you expect a large treatment effect put "blind=FALSE"
#Here we choose blind so that the initial conditions setting does not influence the outcome, ie we want to see if the conditions cluster based purely on the individual datasets, in an unbiased way.


par(mai=ifelse(1:4 <= 2, par('mai'), 0))
px     <- counts(dds)[,1] / sizeFactors(dds)[1]
ord    <- order(px)
ord    <- ord[px[ord]<150]
ord    <- ord[seq(1, length(ord), length=50)]
last   <- ord[length(ord)]
vstcol <- c('blue', 'black')
matplot(px[ord], cbind(assay(vsd)[, 1], log2(px))[ord, ], type='l', lty=1, col=vstcol, xlab='n', ylab='f(n)')
legend('bottomright', legend = c(expression('variance stabilizing transformation'), expression(log[2](n/s[1]))), fill=vstcol)
dev.copy(png,'DESeq2_VST_and_log2.png')



library('vsn')
par(mfrow=c(1,3))
notAllZero <- (rowSums(counts(dds))>0)
meanSdPlot(log2(counts(dds,normalized=TRUE)[notAllZero,] + 1), ylim= c(0,2.5))
meanSdPlot(assay(rld[notAllZero,]), ylim=c(0,2.5))
meanSdPlot(assay(vsd[notAllZero,]), ylim=c(0,2.5))


#Data quality assessment by sample clustering and visualization

# Heatmap of the count table: raw counts, regularized log transformation, variance stabilizing transformation

library('RColorBrewer')
library('gplots')
select <- order(rowMeans(counts(dds,normalized=TRUE)),decreasing=TRUE)[1:30]
hmcol<- colorRampPalette(brewer.pal(9, 'GnBu'))(100)
heatmap.2(counts(dds,normalized=TRUE)[select,], col = hmcol, Rowv = FALSE, Colv = FALSE, scale='none', dendrogram='none', trace='none', margin=c(10,6))
dev.copy(png,'DESeq2_heatmap1')
dev.off()
heatmap.2(assay(rld)[select,], col = hmcol, Rowv = FALSE, Colv = FALSE, scale='none', dendrogram='none', trace='none', margin=c(10, 6))
dev.copy(png,'DESeq2_heatmap2')
dev.off()
heatmap.2(assay(vsd)[select,], col = hmcol, Rowv = FALSE, Colv = FALSE, scale='none', dendrogram='none', trace='none', margin=c(10, 6))
dev.copy(png,'DESeq2_heatmap3')
dev.off()

#Heatmap of the sample-to-sample distances
#Sample clustering, apply dist function to the transpose of the transformed count matrix
distsRL <- dist(t(assay(rld)))
mat<- as.matrix(distsRL)
rownames(mat) <- colnames(mat) <- with(colData(dds), paste(sampleConditions , sep=' : '))

hc <- hclust(distsRL)
heatmap.2(mat, trace="none", col = rev(hmcol), margin=c(13, 13))
dev.copy(png,'deseq2_heatmaps_samplebysample.png')
dev.off()

#PCA of the samples

print(plotPCA(rld, intgroup=c('Conditions')))
dev.copy(png,'deseq2_pca.png')
dev.off()


#Variations to the standard workflow

#Dealing with count outliers
#RNA-Seq data sometimes contain isolated instances of very large counts that are apparently unrelated to the experimental or study design, and which may be considered outliers.
#The function calculates, for every gene and for every sample, a diagnostic test for outliers called Cook’s distance. 
#Cook’s distance is a measure of how much a single sample is influencing the fitted coefficients for a gene, and a large value of Cook’s distance is intended to indicate an outlier count. 
#DESeq2 automatically flags genes with Cook’s distance above a cutoff and sets their p-values and adjusted p-values to NA.
#An alternate strategy is to replace the outlier counts with the trimmed mean over all samples, adjusted by the size factor for that sample.
#Better if you have several replicates per treatment
ddsClean <- replaceOutliersWithTrimmedMean(dds)

#And we need to rerun all the steps of DESeq with the new trimmed data

ddsClean <- DESeq(ddsClean)
tab <- table(initial = results(dds)$padj < .1, cleaned = results(ddsClean)$padj < .1)
addmargins(tab)
write.csv(as.data.frame(tab),file='sim_condition_treated_results_cleaned_summary_deseq2.csv')
resClean <- results(ddsClean)
write.csv(as.data.frame(resClean),file='sim_condition_treated_results_cleaned_deseq2.csv')

#Dispersion plot shows how the estimates are shrunk from the gene wise values (black dots) toward the fitted estimates, with the final values used in testing being the blue dots

plotDispEsts(dds)
dev.copy(png,"DESeq2_PlotDispersionEstimates.png")
dev.off()

#data clean traitment

head(resClean)
mcols(resClean,use.names=TRUE)

plotMA(ddsClean,ylim=c(-2,2),main='DESeq2')
dev.copy(png,'deseq2_clean_MAplot.png')
dev.off()

rldCleaned <- rlogTransformation(ddsClean, blind=T)
vsdCleaned <- varianceStabilizingTransformation(ddsClean, blind=T)

par(mai = ifelse(1:4 <= 2, par('mai'),0))
px <- counts(ddsClean)[,1] / sizeFactors(ddsClean)[1]
ord <- order(px)
ord <- ord[px[ord] < 150]
ord <- ord[seq(1,length(ord),length=50)]
last <- ord[length(ord)]
vstcol <- c('blue','black')
matplot(px[ord], cbind(assay(vsdCleaned)[,1], log2(px))[ord, ],type='l', lty = 1, col=vstcol, xlab = 'n', ylab = 'f(n)')
legend('bottomright',legend=c(expression('variance stabilizing transformation'), expression(log[2](n/s[1]))), fill=vstcol)
dev.copy(png,"DESeq2_AC2x_variance_stabilizing_Cleaned.png")
dev.off()

print(plotPCA(rldCleaned, intgroup=c('Conditions'), ntop=5000))
dev.copy(png,'DESeq2_AC2_PCA_log_transformed_resLFC1.png')
dev.off()
